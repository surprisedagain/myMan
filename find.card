= find =
== COMMAND FORM ==
    find [-L] <BASEPATH> ... [criteria]

== EXAMPLE ==
    find -not ????

== OPTIONS ==
	-[i]name <PAT>     # <PAT> may contain glob style wildcards * ? [xyz]
	-[i]path <PAT>     # as per -name but whole path is tested for match
	-[i]regex <PAT>    # regex BRE by default. -E makes ERE - see [[re]]
				         i is for case Insensitive

	-depth <n>         # depth of file from start path is exactly n
	-mindepth <n>        in base directory = depth 1
	-maxdepth <n>
	
	-samefile <FILE>    # is hardlink to <FILE>
	-links <N>		    # has less/exact/more than -n/n/+n links

	-atime <n>[smhdw]    # accessed less/exact/more than -n/n/+n time units ago
	-mtime <n>[smhdw]    # modified (contents or permissions changed)
	-ctime <n>[smhdw]    # changed (contents changed)

	-ls        # give long listing of matches not just names
	-L         # follow symlinks (default is to use links properties)
	-print0    # if output is piped to xargs this fixes separator
                 use "xargs -0" flag

	-exec <CMD> [arg ...] ;
               # '{}' is path to current file. ';' is non-negotiable
	-execdir
	-ok	       # exec but asks perission first
	-okdir
	
	
	-or     # e.g. \( -newer ttt -or -user wnj \) 
	-not
